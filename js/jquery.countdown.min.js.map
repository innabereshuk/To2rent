{"version":3,"sources":["jquery.countdown.js"],"names":["createDigits","where","options","mFirstPos","sFirstPos","counter","digits","intervals","i","startTime","length","parseInt","elem","$","css","height","digitHeight","float","background","image","width","digitWidth","current","push","margin","digitImages","continuous","_max","format","pos","isStart","text","append","makeMovement","steps","isForward","window","clearInterval","initialPos","x","setInterval","diff","stepTime","val","undefined","backgroundPosition","moveDigit","main","timerEnd","parseRelativeDate","form","mm","s","now","Date","d","getDate","m","getMonth","y","getFullYear","h","getHours","parts","split","indexOf","slice","substr","join","map","pad","formatCompute","parse","Math","floor","getUTCHours","getUTCMinutes","getUTCSeconds","replace","$0","start","element","attr","data","jQuery","fn","countdown","userOptions","extend","endTime","getTime","this"],"mappings":"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","file":"jquery.countdown.min.js","sourcesContent":["/*\r\n * jquery-countdown plugin\r\n *\r\n * Copyright (c) 2009 Martin Conte Mac Donell <Reflejo@gmail.com>\r\n * Dual licensed under the MIT and GPL licenses.\r\n * http://docs.jquery.com/License\r\n *\r\n */\r\n\r\n// Draw digits in given container\r\nvar createDigits = function(where, options) {\r\n  var counter = 0;\r\n  // Iterate each startTime digit, if it is not a digit\r\n  // we'll asume that it's a separator\r\n  var mFirstPos, sFirstPos;\r\n  // reset digits and intervals array.\r\n  digits = [];\r\n  intervals = [];\r\n\r\n  for (var i = 0; i < options.startTime.length; i++) {\r\n    if (parseInt(options.startTime[i]) >= 0) {\r\n      elem = $('<div id=\"cnt_' + counter + '\" class=\"cntDigit\" />').css({\r\n\theight: options.digitHeight,\r\n\tfloat: 'left',\r\n\tbackground: 'url(\\'' + options.image + '\\')',\r\n\twidth: options.digitWidth\r\n      });\r\n\r\n      elem.current = parseInt(options.startTime[i]);\r\n      digits.push(elem);\r\n\r\n      margin(counter, -elem.current * options.digitHeight * options.digitImages);\r\n\r\n      if (options.continuous === true) {\r\n\tdigits[counter]._max = function() { return 9; };\r\n      } else {\r\n\t// Add max digits, for example, first digit of minutes (mm) has\r\n\t// a max of 5. Conditional max is used when the left digit has reach\r\n\t// the max. For example second \"hours\" digit has a conditional max of 4\r\n\tswitch (options.format[i]) {\r\n\t  case 'h':\r\n\t    digits[counter]._max = function(pos, isStart) {\r\n\t      if (pos % 2 == 0)\r\n\t\treturn 2;\r\n\t      else\r\n\t\treturn (isStart) ? 3: 9;\r\n\t    };\r\n\t    break;\r\n\t  case 'd':\r\n\t    digits[counter]._max = function() { return 9; };\r\n\t    break;\r\n\t  case 'm':\r\n\t    digits[counter]._max = function(pos) {\r\n\t      if(!mFirstPos) { mFirstPos = pos; } \r\n\t      return pos == mFirstPos ? 9 : 5;\r\n\t    };\r\n\t    break;\r\n\t  case 's':\r\n\t    digits[counter]._max = function(pos) {\r\n\t      if(!sFirstPos) { sFirstPos = pos; } \r\n\t      return pos == sFirstPos ? 9 : 5;\r\n\t    };\r\n\t}\r\n      }\r\n\r\n      counter += 1;\r\n    } else {\r\n      elem = $('<div class=\"cntSeparator\"/>').css({float: 'left'})\r\n\t\t\t\t\t     .text(options.startTime[i]);\r\n    }\r\n    where.append(elem)\r\n  }\r\n};\r\n\r\nvar makeMovement = function(elem, steps, isForward, options) {\r\n  // Stop any other movement over the same digit.\r\n  if (intervals[elem])\r\n    window.clearInterval(intervals[elem]);\r\n\r\n  // Move to the initial position (We force that because in chrome\r\n  // there are some scenarios where digits lost sync)\r\n  var initialPos = -(options.digitHeight * options.digitImages *\r\n\t\t     digits[elem].current);\r\n  margin(elem, initialPos);\r\n  digits[elem].current = digits[elem].current + ((isForward) ? steps: -steps);\r\n\r\n  var x = 0;\r\n  intervals[elem] = setInterval(function() {\r\n    if (x++ === options.digitImages * steps) {\r\n      window.clearInterval(intervals[elem]);\r\n      delete intervals[elem];\r\n      return;\r\n    }\r\n\r\n    var diff = isForward ? -options.digitHeight: options.digitHeight;\r\n    margin(elem, initialPos + (x * diff));\r\n  }, options.stepTime / steps);\r\n};\r\n\r\n// Set or get element margin\r\nvar margin = function(elem, val) {\r\n  if (val !== undefined) {\r\n    digits[elem].margin = val;\r\n    return digits[elem].css({'backgroundPosition': '0 ' + val + 'px'});\r\n  }\r\n\r\n  return digits[elem].margin || 0;\r\n};\r\n\r\n\r\n// Makes the movement. This is done by \"digitImages\" steps.\r\nvar moveDigit = function(elem, options) {\r\n  if (digits[elem].current == 0) {\r\n    // Is there still time left?\r\n    if (elem > 0) {\r\n      var isStart = (digits[elem - 1].current == 0);\r\n\r\n      makeMovement(elem, digits[elem]._max(elem, isStart), true, options);\r\n      moveDigit(elem - 1, options);\r\n    } else { // That condition means that we reach the end! 00:00.\r\n      for (var i = 0; i < digits.length; i++) {\r\n\tclearInterval(intervals[i]);\r\n\tclearInterval(intervals.main);\r\n\tmargin(i, 0);\r\n      }\r\n      options.timerEnd();\r\n    }\r\n    return;\r\n  }\r\n  makeMovement(elem, 1, false, options);\r\n};\r\n\r\n\r\n\r\n// parses a date of the form hh:mm:ss, for example, where\r\n// ... precision is the same as the format.\r\nvar parseRelativeDate = function(form, options) {\r\n  // give the date the values of now by default\r\n  var now = new Date();\r\n  var d = now.getDate();\r\n  var m = now.getMonth() + 1;\r\n  var y = now.getFullYear();\r\n  var h = now.getHours(), mm, s;\r\n\r\n  // read in components and render based on format\r\n  var format = options.format;\r\n  var parts = form.split(':');\r\n  if( format.indexOf('dd') == 0 ) {\r\n      d = parts[0];\r\n      parts = parts.slice(1);\r\n      format = format.substr(3);\r\n  }\r\n  if( format.indexOf('hh') == 0 ) {\r\n      h = parts[0];\r\n      parts = parts.slice(1);\r\n      format = format.substr(3);\r\n  }\r\n  if( format.indexOf('mm') == 0 ) {\r\n      mm = parts[0];\r\n      parts = parts.slice(1);\r\n      format = format.substr(3);\r\n  }\r\n  if( format.indexOf('ss') == 0 ) {\r\n      s = parts[0];\r\n      parts = parts.slice(1);\r\n      format = format.substr(3);\r\n  }\r\n  // return our constructed date object\r\n  return new Date([m, d, y].join('/') + ' ' + [h, mm, s].map(pad).join(':') + ' GMT-0900');\r\n};\r\n\r\n\r\n// convert a date object to the format specified\r\nvar formatCompute = function(d, options) {\r\n      var format = options.format;\r\n      var parse = {\r\n\td: Math.floor( ( d - new Date( d.getFullYear(), 0, 1 ) ) / ( 1000 * 60 * 60 * 24 ) ),\r\n\th: d.getUTCHours(),\r\n\tm: d.getUTCMinutes(),\r\n\ts: d.getUTCSeconds()\r\n      };\r\n      return format.replace(/(dd|hh|mm|ss)/g, function($0, form) {\r\n\t      return pad(parse[form[0]]);\r\n      });\r\n};\r\n\r\n// add leading zeros\r\nvar pad = function(x){return (1e15+\"\"+x).slice(-2)};\r\n\r\nvar start = function (element) {\r\n\tif (element.attr('started') != 'true') {\t\r\n\t\telement.attr('started', true)\r\n\t\tintervals.main = setInterval(function () {\r\n\t\t\t\tmoveDigit(digits.length - 1, element.data('options'));\r\n\t\t\t},\r\n\t\t\t1000);\r\n\t}\r\n};\r\n\r\nvar digits = [];\r\nvar intervals = [];\r\njQuery.fn.countdown = function(userOptions) {\r\n  // Default options\r\n  var options = {\r\n    stepTime: 60,\r\n    // startTime and format MUST follow the same format.\r\n    // also you cannot specify a format unordered (e.g. hh:ss:mm is wrong)\r\n    format: \"dd:hh:mm:ss\",\r\n    startTime: \"01:12:32:55\",\r\n    digitImages: 6,\r\n    digitWidth: 67,\r\n    digitHeight: 90,\r\n    timerEnd: function(){},\r\n    image: \"digits.png\",\r\n    continuous: false,\r\n\tstart: true\r\n  };\r\n  $.extend(options, userOptions);\r\n\r\n  // if an endTime is provided...\r\n  if( userOptions.endTime ) {\r\n    // calculate the difference between endTime and present time\r\n    var endDate = userOptions.endTime instanceof Date ? userOptions.endTime : parseRelativeDate(userOptions.endTime, options);\r\n    var diff = endDate.getTime() - (new Date()).getTime();\r\n  \t// and set that as the startTime\r\n    userOptions.startTime = formatCompute(new Date(diff), options);\r\n    delete userOptions.endTime;\r\n  }\r\n  $.extend(options, userOptions);\r\n  if (this.length) {\r\n    clearInterval(intervals.main);\r\n    createDigits(this, options);\r\n\tthis.data('options', options);\r\n\tif (options.start === true) {\r\n\t\tstart(this);\r\n\t}\r\n  }\r\n};\r\n\r\n// start the counter\r\njQuery.fn.start = function () {\r\n\tstart(this);\r\n};"]}